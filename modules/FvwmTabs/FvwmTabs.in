#!/usr/bin/perl -w

# $Id$

# 	FvwmTabs
#	Copyright (C) 2002, 2003 Scott Smedley ss@aao.gov.au
#	
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# see: http://users.tpg.com.au/users/scottie7/fvwmtabs.html
# for how to install/use this module.

use strict;
use lib `fvwm-perllib dir`;
use FVWM::Module;
use FVWM::Module::Toolkit 'X11::Protocol';
use FVWM::Module::Toolkit 'Tk';	# aka: use Tk;
use FVWM::Module::Tk;

use vars qw($TOP $fvwm $xServer %tabWin @autoSwallow);


$TOP = new MainWindow();
$TOP->withdraw();
# Why does FVWM::Module::Tk require a widget?
$fvwm = new FVWM::Module::Tk($TOP,
							 Name => "FvwmTabs",
							 Mask => (M_ERROR | M_STRING | M_ADD_WINDOW),
							 Debug => 0);

$fvwm->debug("Debug level is: " . $fvwm->{debug});
$fvwm->addDefaultErrorHandler();

# ======= ======= =======

my $configTracker = $fvwm->track('ModuleConfig',
		 DefaultConfig => {activeBG => 'MidnightBlue',
						   activeFG => 'yellow',
						   inactiveBG => 'royalblue',
						   inactiveFG => 'antiquewhite',
						   titleFG => 'black',
						   titleBG => 'antiquewhite',
						   activeButtonRelief => 'sunken',
						   pollRate => 250,	# in milliseconds.
						   autoSwallowClass => '',
						   autoSwallowResource => '',
						   autoSwallowName => 'test1'});
my $pConfig = $configTracker->data;
$configTracker->observe("config line added", sub {
	# 1st arg is FVWM::Module::Tk hash
	# 2nd arg is FVWM::Tracker::ModuleConfig hash
	# 3rd arg is hash of config values
	# 4th arg is name of config value that has changed.
	my $p = $_[3];
	print("Module Config event - \"$p\" changed. New val: $_[2]{$p}\n");
	# print("\targs: " . join(", ", map("$_=" . $_[2]{$_}, keys(%{$_[2]}))) . "\n");
});

# ======= ======= =======

sub autoSwallow (%)
{
	my (%args) = @_;

	$fvwm->debug("AutoSwallow: " . join(", ", map("$_=" . $args{$_},
												  sort(keys(%args)))));
	push(@autoSwallow, \%args);
}

foreach my $type ('Class', 'Resource', 'Name')
{
	foreach (split(/,/, $pConfig->{"autoSwallow$type"}))
	{
		if (!/^\s*(.+?)(\s+(\d+|any))?\s*$/i)
		{
			print($fvwm->name() . ": unparseable autoSwallow$type.\n");
			next;
		}
		autoSwallow(lc($type) => $1, type => (!defined $3 ? 'any' : $3));
	}
}

# ======= ======= =======
# TODO: colorsets
# my $csTracker = $fvwm->track("Colorsets");
# my $csHash = $csTracker->data;
# my $cs1_fg = $csHash->{1}->{fg} || 'unknown';
# my $cs1_bg = $csHash->{1}->{bg} || 'unknown';
# my $cs5_bg = $csTracker->data(6)->{bg} || 'unknown';
# print("cs1_fg=$cs1_fg cs1_bg=$cs1_bg\n");

# $csTracker->observe("colorset changed", sub {
# 	print("Colorset observation.\n");
# 	    foreach (@_)
#     {
#         print("\targ=$_\n");
#     }
# });

# ======= ======= =======

sub createNewTabber ()
{
	my $tId;
	for ($tId = 0; ; $tId++)
	{
		last if (!defined($tabWin{$tId}));
	}

	my $title = "FvwmTabs [$tId]";
	my $tl = $TOP->Toplevel(Name => $fvwm->name(),
							-class => $fvwm->name(),
							-title => $title);
	$tl->iconname($title);
	$tl->focusmodel("active");
	my $topFrame = $tl->Frame();
	my $tabFrame = $topFrame->Frame();
	$tabFrame->pack(-side => 'top', -expand => 0, -fill => 'x');
	$topFrame->pack(-expand => 1, -fill => 'both', -anchor => 'nw');

	my $titleFrame = $topFrame->Label(-text => "No title",
									  -bg => $pConfig->{titleBG},
									  -fg => $pConfig->{titleFG});
	$titleFrame->pack(-expand => 0, -fill => 'x', -side => 'top');

	my $winFrame = $topFrame->Frame();
	$winFrame->pack(-expand => 1, -fill => 'both', -side => 'top');

	$tl->protocol('WM_DELETE_WINDOW', [\&closeTabber, $tId]);
	$tl->protocol('WM_TAKE_FOCUS', [\&takeFocus, $tId]);

	my $b = $tabFrame->Button(-text => "FvwmTabs", -command => [\&tabInfo, $tId]);
	$b->pack(-side => 'left', -expand => 0);

	my $menu = $tl->Menu(-tearoff => 0);

	$b->Tk::bind('<ButtonRelease-3>', sub {
		$menu->delete(0, 'end');
		$menu->add('command', -label => 'Release All', -command => [\&releaseAll, $tId, 0]);
		$menu->add('command', -label => 'Release All (Iconify)', -command => [\&releaseAll, $tId, 1]);
		$menu->add('command', -label => 'Add', -command => [\&pickAndAdd, $tId, '']);
		$menu->add('command', -label => 'Multi Add', -command => [\&pickAndAdd, $tId, 'multi']);
		$menu->add('separator');

		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$menu->add('command', -label => $tabWin{$tId}{tab}[$tabNo]{title},
								 -command => [\&showTab, $tId, $tabNo]);
		}
		$menu->add('separator') if ($tabWin{$tId}{nTabs} > 0);
		$menu->add('command', -label => 'About', -command => [\&about, $tId]);
		$menu->add('command', -label => 'Close', -command => [\&closeTabber, $tId]);
		$menu->Popup(-popanchor => 'nw', -popover => 'cursor');
	});

	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{toplevel} = $tl;
	$tabWin{$tId}{tabFrame} = $tabFrame;
	$tabWin{$tId}{titleFrame} = $titleFrame;
	$tabWin{$tId}{winFrame} = $winFrame;
	$tabWin{$tId}{currentTab} = undef;
	$tabWin{$tId}{parent} = hex($winFrame->id);
	# $tl->wrapper() doesn't work ...
	# selfId appears to be parent + 1 anyway.
	$tabWin{$tId}{selfId} = $tabWin{$tId}{parent} + 1;

	$winFrame->waitVisibility();

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask('ResizeRedirect'));
}

sub takeFocus ($)
{
	my ($tId) = @_;

	my $winId;
	if (!defined $tabWin{$tId}{currentTab})
	{
		$winId = $tabWin{$tId}{selfId};
	}
	else
	{
		$winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
	}
	$xServer->SetInputFocus($winId, 'Parent', 'CurrentTime');
}

# Don't you just *love* Prince!?
sub letItGo ($$$$)
{
	my ($button, $tId, $tabNo, $bIconify) = @_;

	if ($fvwm->{debug} && $tabNo >= $tabWin{$tId}{nTabs})
	{
		$fvwm->debug("BUG: invalid tabNo.");
		return;
	}

	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->ReparentWindow($winId, $xServer->root(), (0, 0));
	# position the window at the location we found it. (ie. before the
	# window was added to this tabber.)
	$xServer->ConfigureWindow($winId,
							  x => $tabWin{$tId}{tab}[$tabNo]{initialXPos},
							  y => $tabWin{$tId}{tab}[$tabNo]{initialYPos});
	$xServer->MapWindow($winId);
	$fvwm->send("WindowId $winId Iconify") if ($bIconify);
	removeTab($tId, $tabNo, 'letgo');
}


# release all windows from <$tId> tabber.
sub releaseAll ($$)
{
	my ($tId, $bIconify) = @_;
	for (my $tabNo = $tabWin{$tId}{nTabs} - 1; $tabNo >= 0; $tabNo--)
	{
		letItGo(undef, $tId, $tabNo, $bIconify);
	}
	$tabWin{$tId}{tab} = undef;
	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{currentTab} = undef;
}

sub XSync ()
{
	# There doesn't appear to be an XSync function so we'll just make
	# do with atom() & ignore the return value.
	$xServer->atom("WM_NAME");
}

sub closeTabber ($)
{
	my ($tId) = @_;

	$fvwm->debug("closeTabber($tId)");
	releaseAll($tId, 0);
	$tabWin{$tId}{toplevel}->withdraw();
	# We need to wait for the X server to do the reparenting before
	# we can destroy the window.
	XSync();
	$tabWin{$tId}{toplevel}->destroy();
	delete $tabWin{$tId};
}

sub winIdToTId ($)
{
	my ($winId) = @_;

	foreach my $tId (keys(%tabWin))
	{
		return $tId if ($winId == $tabWin{$tId}{selfId});
	}
	print("BUGGER: no match on $winId\n");
	return -1;
}


# SendToModule commands should be arriving as M_STRING events.
$fvwm->addHandler(M_STRING, sub {
	my ($self, $event) = @_;

	$fvwm->debug("M_STRING: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));

	if ($event->args->{text} =~ /newTabber/)
	{
		createNewTabber();
	}
	elsif ($event->args->{text} =~ /addme (w?)(\d+)(.*)?/)
	{
		my $bMulti = ($3 eq ' multi');
		my $tId = ($1 eq '' ? $2 : &winIdToTId($2));
		if (!exists $tabWin{$tId})
		{
			printf("Unknown Tabber %d (0x%x)\n", $2, $2);
			return;
		}
		addTab($tId, $event->args->{win_id});
		pickAndAdd($tId, 'multi') if ($bMulti);
	}
	elsif ($event->args->{text} =~ /fn (\S+) (0x[[:xdigit:]]+)\s*(.*)/)
	{
		# fn <fnName> <winId> <optArgs>
		my $tId = winIdToTId(hex($2));
		print("focus not in tabber.\n"), return if ($tId < 0);
		no strict;
		&$1($tId, split(/\s+/, $3));
		# I don't know why, but if we're getting messages to change the
		# shown tab really quickly we get a 'Protocol Error'. The call
		# to callback() below fixes the problem.
		callback();
	}
	else
	{
		print(STDERR $self->name . ": Unknown command: " . $event->args->{text} . "\n");
	}
});

# showNext() - invoked from key binding.
sub showNext ($$)
{
	my ($tId, $inc) = @_;
	my $nextTabNo = ($tabWin{$tId}{currentTab} + $inc) % $tabWin{$tId}{nTabs};
	showTab($tId, $nextTabNo) if ($nextTabNo != $tabWin{$tId}{currentTab});
}

# releaseTab() - invoked from key binding.
sub releaseTab ($$$)
{
	my ($tId, $tabNo, $bIconify) = @_;
	$tabNo = $tabWin{$tId}{currentTab} if ($tabNo eq 'current');
	letItGo(undef, $tId, $tabNo, $bIconify);
}

$fvwm->addHandler(M_ADD_WINDOW, sub {
	my ($self, $event) = @_;

	$fvwm->debug("Add Window: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));
	my $winId = $event->args->{win_id};

	my $s = chr(0);
	my ($resource, $class) = split(/$s/, getProperty($winId, 'WM_CLASS'));
	my $name = getProperty($winId, 'WM_NAME');
	$fvwm->debug("newWindow - resource=$resource class=$class name=$name");

	foreach (@autoSwallow)
	{
		if ((exists $_->{resource} && $_->{resource} eq $resource) ||
			(exists $_->{class} && $_->{class} eq $class) ||
			(exists $_->{name} && $_->{name} eq $name))
		{
			my $tId = $_->{type};
			if ($tId eq 'any')
			{
				my @tIds = keys(%tabWin);
				return if ($#tIds < 0);	# no tabbers running.
				# choose the emptiest tabber.
				my $n = 99;
				foreach (@tIds)
				{
					if ($tabWin{$_}{nTabs} < $n)
					{
						$tId = $_;
						$n = $tabWin{$_}{nTabs};
					}
				}
			}
			addTab($tId, $winId) if (exists $tabWin{$tId})
		}
	}
});

# ON_EXIT handler is invoked just before this module terminates.
$fvwm->addHandler(ON_EXIT, sub {
	my ($self, $event) = @_; 
	print("FvwmTabs: Got ON_EXIT event.\n");
	cleanup();
});

$SIG{PIPE} = sub {
	print("FvwmTabs: SIGPIPE!\n");
	cleanup();
	exit;
};

sub cleanup ()
{
	foreach (keys(%tabWin))
	{
		closeTabber($_);
	}
}

$xServer = X11::Protocol->new($TOP->screen());
# $xServer->{event_handler} = \&eventHandler;
$xServer->event_handler('queue');

sub callback
{
	# $xServer->handle_input();
	# $xServer->next_event();
	# TODO: why do I have to send a req to get events.
	# Need a non-blocking way to get an event.
 	$xServer->req('ListProperties', $xServer->root());
	# XSync(); doesn't work.
	while (1)
	{
		my %event = $xServer->dequeue_event();
		last if (!exists($event{name}));
		eventHandler(%event);
	}
}

# Check for registered X events every $pollRate milliseconds.
$TOP->repeat($pConfig->{pollRate}, \&callback);

sub eventHandler
{
	my (%event) = @_;

	$fvwm->debug("Got a $event{name} event: " . join(", ", map("$_ = $event{$_}", keys(%event))));


	if ($event{name} eq 'ResizeRequest')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{parent} == $event{window});
		}

		return if ($tId < 0);

		my $h = $tabWin{$tId}{winFrame}->height();
		# resize the $winFrame widget. Can't use $w->configure(-height ...)
		# cos we're requesting resize events on this widget.
		$xServer->ConfigureWindow($tabWin{$tId}{parent},
								  "height" => $h, #$event{height},
								  "width" => $event{width});

		# If the tabber is resized, resize the currently viewed app/tab
		# (if any) to fit into the new space.
		return if (!defined $tabWin{$tId}{currentTab});
		my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
		
		$xServer->ConfigureWindow($winId,
								  "height" => $h, # $event{height},
								  "width" => $event{width});
		return;
	}

	my $tabNo = -1;
	my $tId = undef;
	for (keys(%tabWin))
	{
		$tabNo = getTabNo($_, $event{window});
		$tId = $_, last if ($tabNo >= 0)
	}

	if ($tabNo < 0)
	{
		$fvwm->debug("Ignoring event for invalid/unknown window.");
		return;
	}

	if ($event{name} eq 'PropertyNotify')
	{
		my $prop = $xServer->atom_name($event{atom});
		return if ($prop ne 'WM_NAME' && $prop ne 'WM_ICON_NAME');
		my $val = getProperty($event{window}, $prop);
		if ($prop eq 'WM_NAME')
		{
			setTabTitle($tId, $tabNo, $event{window}, $val);
		}
		elsif ($prop eq 'WM_ICON_NAME')
		{
			setTabName($tId, $tabNo, $event{window}, $val);
		}
	}
	elsif ($event{name} eq 'DestroyNotify')
	{
		removeTab($tId, $tabNo, 'destroyed');
	}
	elsif ($event{name} eq 'MapNotify')
	{
		$xServer->SetInputFocus($event{window}, 'Parent', 'CurrentTime');
	}
	else
	{
		$fvwm->debug("Got a strange event: $event{name}");
	}
}

sub addTab ($$)
{
	my ($tId, $winId) = @_;

	if ($winId == $tabWin{$tId}{selfId})
	{
		# can't make tabber a child of itself
		print("Can't add self to tabber!\n");
		$fvwm->send("Beep");
		return;
	}

	my $tabNo = $tabWin{$tId}{nTabs}++;
	$tabWin{$tId}{tab}[$tabNo]{winId} = $winId;

	# save position of window for later.
	my ($na1, $na2, $x, $y) = $xServer->TranslateCoordinates($winId,
															 $xServer->root(),
															 0,
															 0);
	$tabWin{$tId}{tab}[$tabNo]{initialXPos} = $x;
	$tabWin{$tId}{tab}[$tabNo]{initialYPos} = $y;

	$xServer->ReparentWindow($winId, $tabWin{$tId}{parent}, (0, 0));
	my $txt = getProperty($winId, "WM_ICON_NAME");
	$tabWin{$tId}{tab}[$tabNo]{button} =
		$tabWin{$tId}{tabFrame}->Button(-text => $txt,
										-command => [\&showTab, $tId, $tabNo]);
	my $pButton = $tabWin{$tId}{tab}[$tabNo]{button};

	# Raise the FvwmTabs window whenever a tab is selected.
	$pButton->Tk::bind('<ButtonPress-1>', sub { $fvwm->send("Current Raise"); });
	$pButton->pack(-side => 'left', -expand => 1, -fill => 'both');
	$pButton->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $tabNo, 0]);
	$tabWin{$tId}{tab}[$tabNo]{title} = getProperty($winId, "WM_NAME");

	# Ensure we are notified of any attribute changes in the new window.
	# PropertyChange will tell us when WM_NAME or WM_ICON_NAME changes.
	# StructureNotify will tell us when a program running in a tab
	# terminates/is-destroyed.
	$xServer->ChangeWindowAttributes($winId,
			  event_mask => $xServer->pack_event_mask('PropertyChange',
			  										  'StructureNotify'));
	showTab($tId, $tabNo);
}

sub pickAndAdd ($$)
{
	my ($tId, $arg) = @_;
	$fvwm->send("Pick SendToModule *" . $fvwm->name() . " addme $tId $arg");
}

sub tabInfo ($)
{
	my ($tId) = @_;

	print("\nnTabs=$tabWin{$tId}{nTabs}\n");
	printf("parent=0x%x (%d)\n", $tabWin{$tId}{parent}, $tabWin{$tId}{parent});
	printf("self=0x%x (%d)\n", $tabWin{$tId}{selfId}, $tabWin{$tId}{selfId});
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		printf("Tab #$tabNo winId = 0x%x (%d)\n",
			   $tabWin{$tId}{tab}[$tabNo]{winId},
			   $tabWin{$tId}{tab}[$tabNo]{winId});
	}
	print("AutoSwallow:\n");
	foreach my $a (@autoSwallow)
	{
		print("\t" . join(", ", map("$_=" . $a->{$_}, sort(keys(%{$a})))) . "\n");
	}
}

sub getProperty ($$)
{
	my ($winId, $property) = @_;

	my $atom = $xServer->atom($property);
	my @s = $xServer->req('GetProperty', $winId, $atom, "AnyPropertyType", 0, 200, 0);
	return $s[0];
}

# return the tabNo for the specified window ID or -1 if the window is
# not part of the fvwm.
sub getTabNo ($$)
{
	my ($tId, $winId) = @_;
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		return $tabNo if ($tabWin{$tId}{tab}[$tabNo]{winId} == $winId);
	}
	return -1;
}

# the window for <$tabNo> has been destroyed/letgo - cleanup appropriately.
sub removeTab ($$$)
{
	my ($tId, $tabNo, $state) = @_;

	if ($state eq 'letgo')
	{
		# We are no longer interested in events for this window.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{tab}[$tabNo]{winId},
			  event_mask => $xServer->pack_event_mask());
	}

	$tabWin{$tId}{tab}[$tabNo]{button}->packForget();
	$tabWin{$tId}{tab}[$tabNo] = undef;

	for (my $t = $tabNo; $t < $tabWin{$tId}{nTabs} - 1; $t++)
	{
		$tabWin{$tId}{tab}[$t] = $tabWin{$tId}{tab}[$t + 1];
		$tabWin{$tId}{tab}[$t]{button}->configure(-command => [\&showTab, $tId, $t]);
		$tabWin{$tId}{tab}[$t]{button}->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $t, 0]);
	}
	$tabWin{$tId}{nTabs}--;
	$tabWin{$tId}{tab}[$tabWin{$tId}{nTabs}] = undef;

	if ($tabWin{$tId}{currentTab} == $tabNo)
	{
		$tabWin{$tId}{currentTab} = undef;
		if ($tabWin{$tId}{nTabs} > 0)
		{
			showTab($tId, ($tabNo < $tabWin{$tId}{nTabs} ? $tabNo : $tabNo - 1))
		}
		else
		{
			$tabWin{$tId}{titleFrame}->configure(-text => 'No title');
			$tabWin{$tId}{winFrame}->configure(-height => 1, -width => 0);
		}
	}
	elsif ($tabWin{$tId}{currentTab} > $tabNo)
	{
		$tabWin{$tId}{currentTab}--;
	}
}

sub showTab ($$)
{
	my ($tId, $tabNo) = @_;

	if ($tabNo >= $tabWin{$tId}{nTabs})
	{
		print(STDERR "BUG: invalid tabNo ($tabNo) in call to showTab().\n");
		return
	}

	# Unmap the current tab.
	if (defined($tabWin{$tId}{currentTab}))
	{
		my $currentTab = $tabWin{$tId}{currentTab};
		return if ($tabNo == $currentTab);
		my $winId = $tabWin{$tId}{tab}[$currentTab]{winId};
		$xServer->UnmapWindow($winId);
		$tabWin{$tId}{tab}[$currentTab]{button}->configure(
					-bg => $pConfig->{inactiveBG},
					-activebackground => $pConfig->{inactiveBG},
					-fg => $pConfig->{inactiveFG},
					-activeforeground => $pConfig->{inactiveFG},
					-relief => 'raised');
	}
	# Map the new tab.
	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->MapWindow($winId);
	$tabWin{$tId}{currentTab} = $tabNo;
	$tabWin{$tId}{tab}[$tabNo]{button}->configure(
					-bg => $pConfig->{activeBG},
					-activebackground => $pConfig->{activeBG},
					-fg => $pConfig->{activeFG},
					-activeforeground => $pConfig->{activeFG},
					-relief => $pConfig->{activeButtonRelief});
	$tabWin{$tId}{titleFrame}->configure(-text => $tabWin{$tId}{tab}[$tabNo]{title});

	my %g = $xServer->req('GetGeometry', $winId);
	$tabWin{$tId}{winFrame}->configure(-height => $g{height}, -width => $g{width});
	$tabWin{$tId}{toplevel}->geometry("");
}

sub setTabTitle($$$$)
{
	my ($tId, $tabNo, $winId, $titleStr) = @_;

	# This is a nice feature - Wrap the title text across multiple lines.
	# The following command in an xterm window illustrates the usefulness:
	# echo "abc\ndef\nghi\njkl" && sleep 3
	# $titleStr =~ s/"/\\"/g;
	# chomp($titleStr);

	$titleStr =~ s/\n//g;
	$tabWin{$tId}{tab}[$tabNo]{title} = $titleStr;
	if ($tabNo == $tabWin{$tId}{currentTab})
	{
		# get the width of the title label in pixels.
		my $w = $tabWin{$tId}{titleFrame}->width();
		$w -= 30;
		# make sure the title text does not exceed this length.
		$tabWin{$tId}{titleFrame}->configure(-text => $titleStr,
											 -wraplength => "${w}p");
	}
}

sub setTabName($$$$)
{
	my ($tId, $tabNo, $winId, $name) = @_;

	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-text => $name);
}

sub about ($)
{
	my ($tId) = @_;

	my $rcsId = '$Id$';
	$rcsId =~ /,v (.*) (\d+\/\d+\/\d+) \d+:\d+:\d+/;
	my $version = $fvwm->name() . " v$1   ($2)\n\nby Scott Smedley\nscottie7\@tpg.com.au"; # \n\nhttp://users.tpg.com.au/users/scottie7/fvwmtabs.html";
	# TODO: Tk::Dialog has a hardcoded wraplength of 3 inches, how annoying!
	$tabWin{$tId}{toplevel}->Dialog(-text => $version,
									-bitmap => 'info',
									-title => 'About ' . $fvwm->name(),
									-buttons => ['Ok'])->Show();
}

print("Module " . $fvwm->name() . " started.\n");
$fvwm->eventLoop();


# TODO
#
# - when user resizes window, dynamic-resizes no longer work.
# - colorset support & dynamic configuration options.
#   (waiting for support in fvwm-perllib)
# - consider removing the 'FvwmTabs' button & using the menu popup over
#   the title frame.
# - associate a mini icon with each tab-button.
# - Preserve state b/w FVWM Restarts.
