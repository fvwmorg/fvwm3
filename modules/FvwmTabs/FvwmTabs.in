#!/usr/bin/perl -w

# $Id$

# 	FvwmTabs
#	Copyright (C) 2002 Scott Smedley ss@aao.gov.au
#	
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# see: http://users.tpg.com.au/users/scottie7/fvwmtabs.html
# for how to install/use this module.

use strict;
use vars qw($TOP $fvwm $xServer %tabWin);
use X11::Protocol;
use Tk;

use lib `fvwm-perllib dir`;
use FVWM::Module::Tk;

# TODO: colors, etc - make configurable.
my %config = (activeBG => 'MidnightBlue',
			  activeFG => 'yellow',
			  inactiveBG => 'royalblue',
			  inactiveFG => 'antiquewhite',
			  titleBG => 'antiquewhite',
			  bDebug => 0);

sub autoSwallow ($$$$)
{
	my ($resource, $class, $name, $tId) = @_;

	my %p;
	$p{resource} = $resource if (defined $resource);
 	$p{class} = $class if (defined $class);
 	$p{name} = $name if (defined $name);
 	$p{type} = $tId;	# can be a tId or 'any'.

	push(@{$config{autoSwallow}}, \%p);
}

# specify patterns for windows to be auto-"swallowed".
autoSwallow('xterm', undef, undef, 0);
autoSwallow(undef, undef, 'xload', 'any');


$TOP = new MainWindow();
$TOP->withdraw();
# Why does FVWM::Module::Tk require a widget?
$fvwm = new FVWM::Module::Tk($TOP,
							 Name => "FvwmTabs",
							 Mask => (M_ERROR | M_STRING | M_ADD_WINDOW));

$fvwm->addDefaultErrorHandler();

# TODO: read configuration settings from FVWM, etc.
# my $params = $fvwm->readConfigInfo();
# foreach (keys(%params))
# {
# 	print("$_=$params{$_}\n");
# }

sub createNewTabber ()
{
	my $tId;
	for ($tId = 0; ; $tId++)
	{
		last if (!defined($tabWin{$tId}));
	}

	my $title = "FvwmTabs [$tId]";
	my $tl = $TOP->Toplevel(Name => $fvwm->name(),
							-class => $fvwm->name(),
							-title => $title);
	$tl->iconname($title);
	$tl->focusmodel("active");
	my $topFrame = $tl->Frame();
	my $tabFrame = $topFrame->Frame();
	$tabFrame->pack(-side => 'top', -expand => 0, -fill => 'x');
	$topFrame->pack(-expand => 1, -fill => 'both', -anchor => 'nw');

	my $titleFrame = $topFrame->Label(-text => "No title", -bg => $config{titleBG});
	$titleFrame->pack(-expand => 0, -fill => 'x', -side => 'top');

	my $winFrame = $topFrame->Frame();
	$winFrame->pack(-expand => 1, -fill => 'both', -side => 'top');

	$tl->protocol('WM_DELETE_WINDOW', [\&closeTabber, $tId]);
	$tl->protocol('WM_TAKE_FOCUS', [\&takeFocus, $tId]);

	my $b = $tabFrame->Button(-text => "FvwmTabs", -command => [\&tabInfo, $tId]);
	$b->pack(-side => 'left', -expand => 0);

	my $menu = $tl->Menu(-tearoff => 0);

	$b->Tk::bind('<ButtonRelease-3>', sub {
		$menu->delete(0, 'end');
		$menu->add('command', -label => 'Release All', -command => [\&releaseAll, $tId, 0]);
		$menu->add('command', -label => 'Release All (Iconify)', -command => [\&releaseAll, $tId, 1]);
		$menu->add('command', -label => 'Add', -command => [\&pickAndAdd, $tId, '']);
		$menu->add('command', -label => 'Multi Add', -command => [\&pickAndAdd, $tId, 'multi']);
		$menu->add('separator');

		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$menu->add('command', -label => $tabWin{$tId}{tab}[$tabNo]{title},
								 -command => [\&showTab, $tId, $tabNo]);
		}
		$menu->add('separator') if ($tabWin{$tId}{nTabs} > 0);
		$menu->add('command', -label => 'About', -command => [\&about, $tId]);
		$menu->add('command', -label => 'Close', -command => [\&closeTabber, $tId]);
		$menu->Popup(-popanchor => 'nw', -popover => 'cursor');
	});

	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{toplevel} = $tl;
	$tabWin{$tId}{tabFrame} = $tabFrame;
	$tabWin{$tId}{titleFrame} = $titleFrame;
	$tabWin{$tId}{winFrame} = $winFrame;
	$tabWin{$tId}{currentTab} = undef;
	$tabWin{$tId}{parent} = hex($winFrame->id);
	# $tl->wrapper() doesn't work ...
	# selfId appears to be parent + 1 anyway.
	$tabWin{$tId}{selfId} = $tabWin{$tId}{parent} + 1;

	$winFrame->waitVisibility();

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask('ResizeRedirect'));
}

sub takeFocus ($)
{
	my ($tId) = @_;

	return if (!defined $tabWin{$tId}{currentTab});
	my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
	$xServer->SetInputFocus($winId, 'Parent', 'CurrentTime');
}

# Don't you just *love* Prince!?
sub letItGo ($$$$)
{
	my ($button, $tId, $tabNo, $bIconify) = @_;

	# print("letItGo($tId, $tabNo)\n");

	if ($config{bDebug} && $tabNo >= $tabWin{$tId}{nTabs})
	{
		print(STDERR "BUG: invalid tabNo.\n");
		return;
	}

	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	# print(sprintf("reparenting 0x%x\n", $winId));
	$xServer->ReparentWindow($winId, $xServer->root(), (0, 0));
	$xServer->MapWindow($winId);
	$fvwm->send("WindowId $winId Iconify") if ($bIconify);
	removeTab($tId, $tabNo, 'letgo');
}


# release all windows from <$tId> tabber.
sub releaseAll ($$)
{
	my ($tId, $bIconify) = @_;
	for (my $tabNo = $tabWin{$tId}{nTabs} - 1; $tabNo >= 0; $tabNo--)
	{
		letItGo(undef, $tId, $tabNo, $bIconify);
	}
	$tabWin{$tId}{tab} = undef;
	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{currentTab} = undef;
}

sub closeTabber ($)
{
	my ($tId) = @_;

	print("closeTabber($tId)\n") if ($config{bDebug});
	releaseAll($tId, 0);
	$tabWin{$tId}{toplevel}->withdraw();
	# We need to wait for the X server to do the reparenting before
	# we can destroy the window.
	# There doesn't appear to be an XSync function so we'll just make
	# do with atom() & ignore the return value.
	$xServer->atom("WM_NAME");
	$tabWin{$tId}{toplevel}->destroy();
	delete $tabWin{$tId};
}

sub winIdToTId ($)
{
	my ($winId) = @_;

	foreach my $tId (keys(%tabWin))
	{
		return $tId if ($winId == $tabWin{$tId}{selfId});
	}
	print("BUGGER: no match on $winId\n");
	return -1;
}


# SendToModule commands should be arriving as M_STRING events.
$fvwm->addHandler(M_STRING, sub {
	my ($self, $event) = @_;

	if ($config{bDebug})
	{
		foreach (sort(keys %{$event->args}))
		{
			print("\t$_ = " . $event->args->{$_} . "\n");
		}
	}

	if ($event->args->{text} =~ /newTabber/)
	{
		createNewTabber();
	}
	elsif ($event->args->{text} =~ /addme (w?)(\d+) (multi)?/)
	{
		my $bMulti = (defined $3);
		my $tId = ($1 eq '' ? $2 : &winIdToTId($2));
		if (!exists $tabWin{$tId})
		{
			printf("Unknown Tabber %d (0x%x)\n", $2, $2);
			return;
		}
		addTab($tId, $event->args->{win_id});
		pickAndAdd($tId, 'multi') if ($bMulti);
	}
	else
	{
		print(STDERR $self->name . ": Unknown command: " . $event->args->{text} . "\n");
	}
});

$fvwm->addHandler(M_ADD_WINDOW, sub {
	my ($self, $event) = @_;

	print("Add Window: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))) . "\n") if ($config{bDebug});
	my $winId = $event->args->{win_id};

	my $s = chr(0);
	my ($resource, $class) = split(/$s/, getProperty($winId, 'WM_CLASS'));
	print("FvwmTabs: resource=$resource\n");
	print("FvwmTabs: class=$class\n");
	my $name = getProperty($winId, 'WM_NAME');
	print("FvwmTabs: name=$name\n");

	foreach (@{$config{autoSwallow}})
	{
		if ((exists $_->{resource} && $_->{resource} eq $resource) ||
			(exists $_->{class} && $_->{class} eq $class) ||
			(exists $_->{name} && $_->{name} eq $name))
		{
			my $tId = $_->{type};
			if ($_->{type} eq 'any')
			{
				my @tIds = keys(%tabWin);
				return if ($#tIds < 0);	# no tabbers running.
				$tId = $tIds[rand @tIds];
			}
			addTab($tId, $winId) if (exists $tabWin{$tId})
		}
	}
});

# ON_EXIT handler is invoked just before this module terminates.
$fvwm->addHandler(ON_EXIT, sub {
	my ($self, $event) = @_; 
	print("FvwmTabs: Got ON_EXIT event.\n");
	cleanup();
});

$SIG{PIPE} = sub {
	print("FvwmTabs: SIGPIPE!\n");
	cleanup();
	exit;
};

sub cleanup ()
{
	foreach (keys(%tabWin))
	{
		closeTabber($_);
	}
}

$xServer = X11::Protocol->new($TOP->screen());
# $xServer->{event_handler} = \&eventHandler;
$xServer->event_handler('queue');

sub callback
{
	# print("#");
	# $xServer->handle_input();
	# $xServer->next_event();
	# TODO: why do I have to send a req to get events.
	# Need a non-blocking way to get an event.
 	$xServer->req('ListProperties', $xServer->root());
	while (1)
	{
		my %event = $xServer->dequeue_event();
		last if (!exists($event{name}));
		eventHandler(%event);
	}
}

# Check for registered X events every second.
$TOP->repeat(250, \&callback);

sub eventHandler
{
	my (%event) = @_;

	print("Got a $event{name} event: " . join(", ", map("$_ = $event{$_}", keys(%event))) . "\n") if ($config{bDebug});


	if ($event{name} eq 'ResizeRequest')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{parent} == $event{window});
		}

		return if ($tId < 0);

		# resize the $winFrame widget. Can't use $w->configure(-height ...)
		# cos we're requesting resize events on this widget.
		$xServer->ConfigureWindow($tabWin{$tId}{parent},
								  "height" => $event{height},
								  "width" => $event{width});

		# If the tabber is resized, resize the currently viewed app/tab
		# (if any) to fit into the new space.
		return if (!defined $tabWin{$tId}{currentTab});
		my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
		
		$xServer->ConfigureWindow($winId,
								  "height" => $event{height},
								  "width" => $event{width});
		return;
	}

	my $tabNo = -1;
	my $tId = undef;
	for (keys(%tabWin))
	{
		$tabNo = getTabNo($_, $event{window});
		$tId = $_, last if ($tabNo >= 0)
	}

	if ($tabNo < 0)
	{
		print(STDERR "FvwmTabs: Ignoring event for invalid/unknown window.\n");
		return;
	}

	if ($event{name} eq 'PropertyNotify')
	{
		my $prop = $xServer->atom_name($event{atom});
		return if ($prop ne 'WM_NAME' && $prop ne 'WM_ICON_NAME');
		my $val = getProperty($event{window}, $prop);
		if ($prop eq 'WM_NAME')
		{
			setTabTitle($tId, $tabNo, $event{window}, $val);
		}
		elsif ($prop eq 'WM_ICON_NAME')
		{
			setTabName($tId, $tabNo, $event{window}, $val);
		}
	}
	elsif ($event{name} eq 'DestroyNotify')
	{
		removeTab($tId, $tabNo, 'destroyed');
	}
	elsif ($event{name} eq 'MapNotify')
	{
		$xServer->SetInputFocus($event{window}, 'Parent', 'CurrentTime');
	}
	else
	{
		print(STDERR "Got a strange event: $event{name}\n") if ($config{bDebug});
	}
}

sub addTab ($$)
{
	my ($tId, $winId) = @_;

	# print("addTab($tId, $winId)\n");

	my %g = $xServer->req('GetGeometry', $winId);
	# TODO: save geometry of window for later.
	# foreach my $k (keys(%g))
	# {
	# 	print("\tgeom: $k = $g{$k}\n");
	# }
	print("geom: x=$g{x} y=$g{y} w=$g{width} h=$g{height}\n") if ($config{bDebug});

	# print("tId=$tId\n");
	# print("addTab parent=" . $tabWin{$tId}{parent} . "\n");
	# printf("reparenting 0x%x to 0x%x\n", $winId, $tabWin{$tId}{parent});

	if ($winId == $tabWin{$tId}{selfId})
	{
		# can't make tabber a child of itself
		print("Can't add self to tabber!\n");
		$fvwm->send("Beep");
		return;
	}

	$xServer->ReparentWindow($winId, $tabWin{$tId}{parent}, (0, 0));
	my $tabNo = $tabWin{$tId}{nTabs}++;
	# print("tabNo=$tabNo\n");
	$tabWin{$tId}{tab}[$tabNo]{winId} = $winId;
	my $txt = getProperty($winId, "WM_ICON_NAME");
	$tabWin{$tId}{tab}[$tabNo]{button} =
		$tabWin{$tId}{tabFrame}->Button(-text => $txt,
										-command => [\&showTab, $tId, $tabNo]);
	my $pButton = $tabWin{$tId}{tab}[$tabNo]{button};

	# Raise the FvwmTabs window whenever a tab is selected.
	$pButton->Tk::bind('<ButtonPress-1>', sub { $fvwm->send("Current Raise"); });
	$pButton->pack(-side => 'left', -expand => 1, -fill => 'both');
	$pButton->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $tabNo, 0]);
	$tabWin{$tId}{tab}[$tabNo]{title} = getProperty($winId, "WM_NAME");
	# Ensure we are notified of any attribute changes in the new window.
	# PropertyChange will tell us when WM_NAME or WM_ICON_NAME changes.
	# StructureNotify will tell us when a program running in a tab
	# terminates/is-destroyed.
	$xServer->ChangeWindowAttributes($winId,
			  event_mask => $xServer->pack_event_mask('PropertyChange',
			  										  'StructureNotify'));
	showTab($tId, $tabNo);
}

sub pickAndAdd ($$)
{
	my ($tId, $arg) = @_;
	$fvwm->send("Pick SendToModule *" . $fvwm->name() . " addme $tId $arg");
}

sub tabInfo ($)
{
	my ($tId) = @_;

	print("\nnTabs=$tabWin{$tId}{nTabs}\n");
	printf("parent=0x%x\n", $tabWin{$tId}{parent});
	printf("self=0x%x\n", $tabWin{$tId}{selfId});
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		printf("Tab #$tabNo winId = 0x%x (%d)\n",
			   $tabWin{$tId}{tab}[$tabNo]{winId},
			   $tabWin{$tId}{tab}[$tabNo]{winId});
	}
}

sub getProperty ($$)
{
	my ($winId, $property) = @_;

	my $atom = $xServer->atom($property);
	my @s = $xServer->req('GetProperty', $winId, $atom, "AnyPropertyType", 0, 200, 0);
	return $s[0];
}

# return the tabNo for the specified window ID or -1 if the window is
# not part of the fvwm.
sub getTabNo ($$)
{
	my ($tId, $winId) = @_;
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		return $tabNo if ($tabWin{$tId}{tab}[$tabNo]{winId} == $winId);
	}
	return -1;
}

# the window for <$tabNo> has been destroyed/letgo - cleanup appropriately.
sub removeTab ($$$)
{
	my ($tId, $tabNo, $state) = @_;

	# print("removeTab($tId, $tabNo, $state)\n");

	if ($state eq 'letgo')
	{
		# We are no longer interested in events for this window.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{tab}[$tabNo]{winId},
			  event_mask => $xServer->pack_event_mask());
	}

	$tabWin{$tId}{tab}[$tabNo]{button}->packForget();
	$tabWin{$tId}{tab}[$tabNo] = undef;

	for (my $t = $tabNo; $t < $tabWin{$tId}{nTabs} - 1; $t++)
	{
		$tabWin{$tId}{tab}[$t] = $tabWin{$tId}{tab}[$t + 1];
		# printf("new tab #$t = 0x%x\n", $tabWin{$tId}{tab}[$t]{winId});
		$tabWin{$tId}{tab}[$t]{button}->configure(-command => [\&showTab, $tId, $t]);
		$tabWin{$tId}{tab}[$t]{button}->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $t, 0]);
	}
	$tabWin{$tId}{nTabs}--;
	$tabWin{$tId}{tab}[$tabWin{$tId}{nTabs}] = undef;

	if ($tabWin{$tId}{currentTab} == $tabNo)
	{
		$tabWin{$tId}{currentTab} = undef;
		if ($tabWin{$tId}{nTabs} > 0)
		{
			showTab($tId, ($tabNo < $tabWin{$tId}{nTabs} ? $tabNo : $tabNo - 1))
		}
		else
		{
			$tabWin{$tId}{titleFrame}->configure(-text => 'No title');
			# TODO: proper resize.
			$tabWin{$tId}{winFrame}->configure(-height => 1, -width => 0);
		}
	}
	elsif ($tabWin{$tId}{currentTab} > $tabNo)
	{
		$tabWin{$tId}{currentTab}--;
	}
}

sub showTab ($$)
{
	my ($tId, $tabNo) = @_;

	# print("showTab($tId, $tabNo)\n");

	if ($tabNo >= $tabWin{$tId}{nTabs})
	{
		print(STDERR "BUG: invalid tabNo ($tabNo) in call to showTab().\n");
		return
	}

	# Unmap the current tab.
	if (defined($tabWin{$tId}{currentTab}))
	{
		my $currentTab = $tabWin{$tId}{currentTab};
		# print("showTab: currentTab=$currentTab\n");
		return if ($tabNo == $currentTab);
		my $winId = $tabWin{$tId}{tab}[$currentTab]{winId};
		$xServer->UnmapWindow($winId);
		$tabWin{$tId}{tab}[$currentTab]{button}->configure(-bg => $config{inactiveBG},
													  -activebackground => $config{inactiveBG},
													  -fg => $config{inactiveFG},
													  -activeforeground => $config{inactiveFG},
													  -relief => 'raised');
	}
	# Map the new tab.
	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->MapWindow($winId);
	$tabWin{$tId}{currentTab} = $tabNo;
	# TODO: option sunken or flat.
	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-bg => $config{activeBG},
												  -activebackground => $config{activeBG},
												  -fg => $config{activeFG},
												  -activeforeground => $config{activeFG},
												  -relief => 'sunken');
	$tabWin{$tId}{titleFrame}->configure(-text => $tabWin{$tId}{tab}[$tabNo]{title});

	my %g = $xServer->req('GetGeometry', $winId);
	$tabWin{$tId}{winFrame}->configure(-height => $g{height}, -width => $g{width});
	# print("showTab h=$g{height} w=$g{width}\n");
	$tabWin{$tId}{toplevel}->geometry("");
}

sub setTabTitle($$$$)
{
	my ($tId, $tabNo, $winId, $titleStr) = @_;

	# Mmmm, bugger! This would have been a nice feature - Wrap the title
	# text across multiple lines. But this causes the reparented window
	# to be in the wrong position.
	# The following command in an xterm window illustrates the problem:
	# echo "abc\ndef\nghi\njkl" && sleep 3
	# $titleStr =~ s/"/\\"/g;
	# $titleStr = `echo "$titleStr" | fold -w80 -s`;
	# chomp($titleStr);

	$tabWin{$tId}{tab}[$tabNo]{title} = $titleStr;
	if ($tabNo == $tabWin{$tId}{currentTab})
	{
		$tabWin{$tId}{titleFrame}->configure(-text => $titleStr);
	}
}

sub setTabName($$$$)
{
	my ($tId, $tabNo, $winId, $name) = @_;

	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-text => $name);
}

sub about ($)
{
	my ($tId) = @_;

	print("in about()\n");
	my $rcsId = '$Id$';
	$rcsId =~ /,v (.*) (\d+\/\d+\/\d+) \d+:\d+:\d+/;
	my $version = $fvwm->name() . " v$1   ($2)\n\nby Scott Smedley\nscottie7\@tpg.com.au"; # \n\nhttp://users.tpg.com.au/users/scottie7/fvwmtabs.html";
	# TODO: Tk::Dialog has a hardcoded wraplength of 3 inches, how annoying!
	$tabWin{$tId}{toplevel}->Dialog(-text => $version,
									-bitmap => 'info',
									-title => 'About ' . $fvwm->name(),
									-buttons => ['Ok'])->Show();
}

print("Module " . $fvwm->name() . " started.\n");
$fvwm->eventLoop();


# TODO
#
# - GetGeometry doesn't appear to return x/y only w/h.
#   (use to put windows back where they came from when released.)
# - when user resizes window, dynamic-resizes no longer work.
# - configuration options: bg/fg colors/fonts/sizes, titles, etc.
# - key bindings:
#   * release current tab.
#	* release all tabs.
#	* add new window.
#	* display next tab.
#	* display previous tab.
#	* close tabber.
#	* create new tabber.
# - consider removing the 'FVWM-Tabs' button & using the menu popup over
#   the title frame.
# - associate a mini icon with each tab-button.
# - Preserve state b/w FVWM Restarts.
# - truncate title so $winFrame doesn't grow & therefore cause
#   tabbed app to grow.
# - tons of stuff!
